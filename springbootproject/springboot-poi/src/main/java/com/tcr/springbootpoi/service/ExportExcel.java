package com.tcr.springbootpoi.service;import com.tcr.springbootpoi.annotation.ExportDateFormat;import com.tcr.springbootpoi.annotation.ExportTransient;import com.tcr.springbootpoi.common.utils.excelexp.bean.ExcelHeader;import com.tcr.springbootpoi.common.utils.excelexp.bean.ExcelIndex;import com.tcr.springbootpoi.common.utils.excelexp.bean.ExcelMergeIndex;import org.apache.commons.lang3.time.DateFormatUtils;import org.apache.poi.hssf.usermodel.*;import org.apache.poi.hssf.util.HSSFColor;import org.apache.poi.ss.util.CellRangeAddress;import org.apache.poi.util.IOUtils;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.util.CollectionUtils;import java.awt.*;import java.io.BufferedOutputStream;import java.io.FileOutputStream;import java.io.OutputStream;import java.lang.reflect.Field;import java.lang.reflect.Method;import java.util.*;import java.util.List;public class ExportExcel<T> {    /**     * LOGGER     */    public static final Logger LOGGER = LoggerFactory.getLogger(ExportExcel.class);    /**excel工作簿*/    private HSSFWorkbook workbook;    /***     * 文件名称     */    private String fileName;    /**excel sheet*/    private HSSFSheet sheet;    /***     * excel 的导出内容的字体     */    private HSSFFont bodyFont;    /**导出内容的样式*/    private HSSFCellStyle bodyStyle;    /**奇数行导出的样式*/    private HSSFCellStyle bodyStyleSingle;    /**偶数行导出的样式*/    private HSSFCellStyle bodyStyleDouble;    /**头部字体*/    private HSSFFont headFont;    /**头部样式*/    private HSSFCellStyle headStyle;    /**导出的数据及其他的信息*/    private IExport<T> iExport;    /**样式索引-数据行数*/    private int styleIndex = 0;    /**当前导出的最大的列数*/    private int maxCol = 0;    /**默认的空数据*/    private String defaultNullData = "--";    /**默认的日期格式化*/    private String defaultDatePattern = "yyyy-MM-dd'T'HH:mm:ss";    /**数据格式化map*/    private Map<String, String> formatPattern;    public ExportExcel() {        initWorkBook();    }    /**     * 构造函数     * @param iExport IExport接口     */    public ExportExcel(IExport<T> iExport) {        this.iExport = iExport;        initWorkBook();    }    /***     * 初始化excel的参数     */    public void initWorkBook() {        this.workbook = new HSSFWorkbook();        this.sheet = workbook.createSheet(iExport.getTitle());        this.bodyFont = getFont(workbook, HSSFColor.BLACK.index, HSSFFont.BOLDWEIGHT_NORMAL, (short) 12);        this.bodyStyle = getStyle(workbook, HSSFColor.WHITE.index, bodyFont, false);        HSSFPalette palette = workbook.getCustomPalette(); //wb HSSFWorkbook对象        Color color = Color.decode("#EDEDED");        palette.setColorAtIndex(HSSFColor.LIME.index, (byte) color.getRed(), (byte) color.getGreen(), (byte) color.getBlue());        this.bodyStyleSingle = getStyle(workbook, HSSFColor.LIME.index, bodyFont, true);        //new XSSFColor(Color.decode("#E6E6FA")).getIndex();        this.bodyStyleDouble = getStyle(workbook, HSSFColor.WHITE.index, bodyFont, true);        this.headFont = getFont(workbook, HSSFColor.BLACK.index, HSSFFont.BOLDWEIGHT_BOLD, (short) 12);        this.headStyle = getStyle(workbook, HSSFColor.SKY_BLUE.index, headFont, true);        this.formatPattern = new HashMap<String, String>();    }    /***     * 根据数据的条数获取style     * @param styleIndex 样式索引     * @return     */    private HSSFCellStyle getStyleByStyleIndex(int styleIndex) {        if (styleIndex % 2 == 0) {            return bodyStyleDouble;        }        return bodyStyleSingle;    }    /**     * 这是一个通用的方法，利用了JAVA的反射机制，可以将放置在JAVA集合中并且符号一定条件的数据以EXCEL 的形式输出到指定IO设备上     */    public void exportExcel() throws Exception {        sheet.setDefaultColumnWidth(20);        //产生表格标题行        HSSFRow row = sheet.createRow(0);        //List<ExcelHeader> headers = iExport.getHeader();        int index = createHeader();        //遍历集合数据，产生数据行        Iterator<T> it = iExport.getData().iterator();        while (it.hasNext()) {            //行数            index++;            row = sheet.createRow(index);            T t = it.next();            //利用反射，根据javabean属性的先后顺序，动态调用getXxx()方法得到属性值            //Field[] fields = t.getClass().getDeclaredFields();            List<String> fNames = getBeanFieldNamesList(t.getClass());            //excel的当前行列信息            ExcelIndex excelIndex = new ExcelIndex(index, 0, index, 0);            try {                //将一个数据对象添加到excel列                index = appendDataToRows(fNames, t, row, excelIndex).getCurrentRowNum();                //每一个数据对象在行中的颜色差                styleIndex++;            } catch (Exception e) {                LOGGER.error("导出excel失败", e);                throw e;            }        }        OutputStream out = null;        try {            out = iExport.getOutputStream();            if (out == null) {                out = new BufferedOutputStream(new FileOutputStream(iExport.getFilePath()));            }            workbook.write(out);            out.flush();        } catch (Exception e) {            LOGGER.error("导出excel失败", e);        } finally {            IOUtils.closeQuietly(out);            //IOUtils.closeQuietly(workbook);        }    }    /***     * 获取一个style     * @param workbook 工作簿     * @param backGroundColor 背景色     * @param font 字体     * @param borderStyle 是否需要添加边框样式     * @return     */    private HSSFCellStyle getStyle(HSSFWorkbook workbook, short backGroundColor, HSSFFont font, boolean borderStyle) {        HSSFCellStyle style = workbook.createCellStyle();        style.setAlignment(HSSFCellStyle.ALIGN_CENTER);        style.setFillForegroundColor(backGroundColor);        style.setFillPattern(HSSFCellStyle.SOLID_FOREGROUND);        if (borderStyle) {            style.setBorderBottom(HSSFCellStyle.BORDER_THIN);            style.setBorderLeft(HSSFCellStyle.BORDER_THIN);            style.setBorderRight(HSSFCellStyle.BORDER_THIN);            style.setBorderTop(HSSFCellStyle.BORDER_THIN);        }        style.setFont(font);        return style;    }    /***     * 获取一个字体     * @param workbook 工作簿     * @param color 颜色     * @param boldweight 粗     * @param fontHeightInPoints fontHeightInPoints     * @return     */    private HSSFFont getFont(HSSFWorkbook workbook, short color, short boldweight, short fontHeightInPoints) {        HSSFFont font = workbook.createFont();        font.setColor(color);        font.setFontHeightInPoints(fontHeightInPoints);        font.setBoldweight(boldweight);        return font;    }    /***     * 获取一个bean的属性list     * @param clazz bean的class     * @return     */    private List<String> getBeanFieldNamesList(Class<?> clazz) {        Field[] fields = clazz.getDeclaredFields();        List<String> fNames = new ArrayList<String>();        for (Field field : fields) {            ExportTransient trs = field.getAnnotation(ExportTransient.class);            if (trs == null) {                String fieldName = field.getName();                fNames.add(fieldName);                ExportDateFormat fmt = field.getAnnotation(ExportDateFormat.class);                if (fmt != null) {                    formatPattern.put(fieldName, fmt.value());                }            }        }        return fNames;    }    /***     * 将String数据写入cell     * @param cell cell     * @param textValue 值     */    private void setStringValueToCell(HSSFCell cell, String textValue) {        HSSFRichTextString richString = new HSSFRichTextString(textValue);        richString.applyFont(bodyFont);        cell.setCellValue(richString);    }    /**     * @return the fileName     */    public String getFileName() {        return fileName;    }    /**     * @param fileName the fileName to set     */    public void setFileName(String fileName) {        this.fileName = fileName;    }    /***     * 生成excel头部信息     * @return     */    private int createHeader() {        int maxRow = 0;        int maxCol = 0;        List<ExcelHeader> list = iExport.getHeader();        if (CollectionUtils.isEmpty(list)) {            return maxRow;        }        for (ExcelHeader header : list) {            int row = header.getToRow();            int col = header.getToCol();            if (row > maxRow) {                maxRow = row;            }            if (col > maxCol) {                maxCol = col;            }        }        if (maxCol == 0) {            maxCol = list.size();        }        this.maxCol = maxCol;        appendHeaderToSheet(list, maxRow, maxCol);        return maxRow;    }    /***     * 将excel头部信息写入excel     * @param list 头部列表     * @param maxRow 最大的行     * @param maxCol 最大列     */    private void appendHeaderToSheet(List<ExcelHeader> list, int maxRow, int maxCol) {        for (int i = 0; i <= maxRow; i++) {            HSSFRow row = sheet.createRow(i);            createNullCell(0, maxCol, row, headStyle, false);        }        HSSFCell cell;        for (int j = 0; j < list.size(); j++) {            //row.getCell(i);            ExcelHeader header = list.get(j);            HSSFRow row = sheet.getRow(header.getFromRow());            cell = row.createCell(header.getFromCol());            cell.setCellStyle(headStyle);            HSSFRichTextString text = new HSSFRichTextString(header.getHeadName());            cell.setCellValue(text);            if (header.isMerge()) {                mergeExcel(header.getFromRow(), header.getToRow(), header.getFromCol(), header.getToCol());            }        }    }    /***     * 合并excel     * @param firstRow 第一行     * @param lastRow 最后一列     * @param firstCol 第一列     * @param lastCol 最后一列     */    private void mergeExcel(int firstRow, int lastRow, int firstCol, int lastCol) {        CellRangeAddress add = new CellRangeAddress(firstRow, lastRow, firstCol, lastCol);        sheet.addMergedRegion(add);    }    /***     * 将数据写入到excel     * @param fieldNames 属性列表     * @param data 需要写入的数据     * @param row excel行     * @param index ExcelIndex     * @return     * @throws Exception     */    private ExcelIndex appendDataToRows(List<String> fieldNames, Object data, HSSFRow row, ExcelIndex index) throws Exception {        //HSSFRow row = sheet.createRow(index.getCurrentRowNum());        int cellIndex = 0;        for (int i = 0; i < fieldNames.size(); i++) {            Object value = getDataFieldValue(data, fieldNames.get(i));            HSSFCell cell = row.createCell(index.getCurrentColNum());            cellIndex = cell.getColumnIndex();            cell.setCellStyle(getStyleByStyleIndex(styleIndex));            //当前列和合并结束列都加1            if (value == null) {                index.setCurrentColNum(index.getCurrentColNum() + 1);                setStringValueToCell(cell, defaultNullData);                continue;            }            // 判断值的类型后进行强制类型转换            if (value instanceof Date) {                setStringValueToCell(                        cell,                        DateFormatUtils.format((Date) value,                                formatPattern.containsKey(fieldNames.get(i)) ? formatPattern.get(fieldNames.get(i)) : defaultDatePattern));                index.setCurrentColNum(index.getCurrentColNum() + 1);                continue;            } else if (value instanceof List) {                List<?> list = (List<?>) value;                if (CollectionUtils.isEmpty(list)) {                    continue;                }                List<String> subFName = getBeanFieldNamesList(list.get(0).getClass());                //当前行，当前列，合并开始行列，合并结束行列                ExcelMergeIndex mergeIndex = new ExcelMergeIndex(index.getStartRowNum(), index.getStartColNum(), index.getCurrentRowNum(),                        index.getCurrentColNum());                int rowIndex = index.getCurrentRowNum();                for (int j = 0; j < list.size(); j++) {                    ExcelIndex subIndex = new ExcelIndex(rowIndex, index.getCurrentColNum(), rowIndex, index.getCurrentColNum());                    if (row.getRowNum() != rowIndex) {                        row = sheet.createRow(rowIndex);                        createNullCell(index.getStartColNum(), mergeIndex.getMergeEndColNum(), row, getStyleByStyleIndex(styleIndex), false);                    }                    ExcelIndex curIndex = appendDataToRows(subFName, list.get(j), row, subIndex);                    index.setCurrentRowNum(curIndex.getCurrentRowNum());                    mergeIndex.setMergeEndRowNum(index.getCurrentRowNum());                    if (curIndex.getCurrentRowNum() > rowIndex) {                        rowIndex = curIndex.getCurrentRowNum();                    }                    rowIndex++;                }                mergeExcel(mergeIndex);            } else {                setStringValueToCell(cell, value.toString());                index.setCurrentColNum(index.getCurrentColNum() + 1);                continue;            }        }        if (cellIndex < maxCol) {            createNullCell(cellIndex + 1, maxCol + 1, row, getStyleByStyleIndex(styleIndex), true);        }        return index;    }    /***     * 创建空的cell，合并时保持所有的格式一致.     * @param start 开始列     * @param end 结束列     * @param row excel行     * @param style 样式     * @param defaultData 如果数据为空是否需要添加默认的空数据     */    private void createNullCell(int start, int end, HSSFRow row, HSSFCellStyle style, boolean defaultData) {        for (int i = start; i < end; i++) {            HSSFCell cell = row.getCell(i);            if (cell != null) {                HSSFRichTextString s = cell.getRichStringCellValue();                if (s != null) {                    continue;                }            }            cell = row.createCell(i);            if (defaultData) {                setStringValueToCell(cell, defaultNullData);            }            if (style != null) {                cell.setCellStyle(style);                continue;            }            cell.setCellStyle(bodyStyle);        }    }    /***     * 合并excel     * @param index ExcelMergeIndex     */    private void mergeExcel(ExcelMergeIndex index) {        if (index == null) {            return;        }        int mergeStartRow = index.getMergeStartRowNum();        int mergeEndRow = index.getMergeEndRowNum();        if (mergeStartRow == mergeEndRow) {            return;        }        int mergeStartCol = index.getMergeStartColNum();        int mergeEndCol = index.getMergeEndColNum();        checkMergeStyle(mergeStartRow, mergeEndRow + 1, mergeStartCol, mergeEndCol);        for (int i = mergeStartCol; i < mergeEndCol; i++) {            CellRangeAddress add = new CellRangeAddress(mergeStartRow, mergeEndRow, i, i);            sheet.addMergedRegion(add);        }    }    /***     * 合并之前检查样式，如果样式有问题会造成边框有问题     * @param startRow startRow     * @param endRow endRow     * @param startCol startCol     * @param endCol endCol     */    public void checkMergeStyle(int startRow, int endRow, int startCol, int endCol) {        for (int i = startRow; i < endRow; i++) {            HSSFRow row = sheet.getRow(i);            if (row == null) {                continue;            }            createNullCell(startCol, endCol, row, getStyleByStyleIndex(styleIndex), false);        }    }    /**     * 通过反射获取值     * @param data 数据     * @param fieldName 属性名     * @return     * @throws Exception     */    private Object getDataFieldValue(Object data, String fieldName) throws Exception {        String getMethodName = "get" + fieldName.substring(0, 1).toUpperCase() + fieldName.substring(1);        Method getMethod = data.getClass().getMethod(getMethodName, new Class[] {});        Object value = getMethod.invoke(data, new Object[] {});        return value;    }}